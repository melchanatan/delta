import numpy as np
import math
from cascade import simulate_cascade_control,generate_trapezoidal_trajectory,inverse_kinematics_with_velocity,jacobian,position_control,velocity_control
from visual_kinematics.RobotDelta import RobotDelta
from visual_kinematics.Frame import Frame
from visual_kinematics.RobotTrajectory import RobotTrajectory

# Define Delta robot parameters [r1, r2, l1, l2]
object_pos = [-0.3,-0.2, -0.5]
robot = RobotDelta(np.array([0.16, 0.06, 0.30, 0.50]), object_pos=object_pos, object_speed=90)
# visualize workspace
# robot.ws_lim = np.array([[-math.pi/12, math.pi/2]]*3)
# robot.ws_division = 10
# robot.show(ws=True)
# print(robot.ws_lim)

x,y,z =x_old,y_old,z_old =-0.4,-0.2,-0.5
while True:
    x = x+0.1 # -0.4 to 0.4
    # y = y+0.1 # -0.3 to 0.3
    #z = z-0.1 # -0.5
    # Define trajectory frames
    frames = [
        Frame.from_euler_3(np.array([0., 0., 0.]), np.array([[x_old], [y_old], [z_old]])),
        Frame.from_euler_3(np.array([0., 0., 0.]), np.array([[x], [y], [z]])),
    ]
    trajectory = RobotTrajectory(robot, frames)
    
    _, _, _, _, v = simulate_cascade_control([x,y,z],object_pos)
    trajectory.move_with_speed(speed=round(v), motion="p2p", object_speed=robot.object_speed)
                           

    x_old,y_old,z_old = x,y,z
    # print(x,y,z)
    print(v)

